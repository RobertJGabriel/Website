(function() {
  var SNAKE, autorun, bannerText, header, navText;

  window.robertjames = {};

  header = $('.clearHeader');

  navText = $('#logo1');

  bannerText = $('#logo2');

  robertjames.easterEgg = function() {
    cheet('↑ ↑ ↓ ↓ ← → ← → b a', function() {
      console.log('hi');
      $('#easteregg').modal('show');
    });
  };

  robertjames.events = function() {
    $('.menu-button').click(function(e) {
      $('.menu-bar').addClass('open');
      $('.grey').addClass('show');
      $('.overlay').show();
      e.stopPropagation();
    });
    $(document).click(function(e) {
      if (!$(e.target).is('.menu-bar *,.menu-bar')) {
        $('.menu-bar').removeClass('open');
        $('.grey').removeClass('show');
        $('.overlay').hide();
      }
    });
  };

  robertjames.colors = function() {
    var aTagsElements, h1Elements, h3Elements, hrElements, i;
    if (bannerText.length > 0) {
      h1Elements = document.getElementsByTagName('h1');
      hrElements = document.getElementsByTagName('hr');
      h3Elements = document.getElementsByTagName('h3');
      aTagsElements = document.getElementsByTagName('a');
    }
    if (typeof h1Elements !== 'undefined') {
      i = 1;
      while (i < h1Elements.length) {
        i++;
      }
    }
    if (typeof h3Elements !== 'undefined') {
      i = 0;
      while (i < h3Elements.length) {
        i++;
      }
    }
    if (typeof hrElements !== 'undefined') {
      i = 0;
      while (i < hrElements.length) {
        i++;
      }
    }
    if (typeof aTagsElements !== 'undefined') {
      i = 6;
      while (i < aTagsElements.length) {
        i++;
      }
    }
  };

  robertjames.init = function() {
    robertjames.events();
    robertjames.easterEgg();
    robertjames.colors();
    navText.addClass('show');
    navText.text('Robert James Gabriel');
  };

  robertjames.init();

  autorun = function() {
    var ServiceWorker;
    ServiceWorker = void 0;
    ServiceWorker = (function() {
      var ServiceWorker;
      ServiceWorker = function() {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('./serviceWorker.js').then((function(_this) {
            return function(registration) {
              if (registration.installing) {

              } else if (registration.waiting) {

              } else if (registration.active) {
                _this.subscribe(registration);
              }
            };
          })(this))['catch'](function(err) {});
        }
      };
      ServiceWorker.prototype.unsubscribe = function(serviceWorkerReg) {
        if ('serviceWorker' in navigator) {
          serviceWorkerReg.pushManager.getSubscription().then(function(subscription) {
            subscription.unsubscribe();
          });
        }
      };
      ServiceWorker.prototype.subscribe = function(serviceWorkerReg) {
        if ('serviceWorker' in navigator) {
          serviceWorkerReg.pushManager.subscribe({
            userVisibleOnly: true
          }).then(function(subscription) {});
          return;
        }
      };
      return ServiceWorker;
    })();
    return new ServiceWorker;
  };

  SNAKE = SNAKE || {};


  /**
  * @method addEventListener
  * @param {Object} obj The object to add an event listener to.
  * @param {String} event The event to listen for.
  * @param {Function} funct The function to execute when the event is triggered.
  * @param {Boolean} evtCapturing True to do event capturing, false to do event bubbling.
   */

  SNAKE.addEventListener = (function() {
    if (window.addEventListener) {
      return function(obj, event, funct, evtCapturing) {
        obj.addEventListener(event, funct, evtCapturing);
      };
    } else if (window.attachEvent) {
      return function(obj, event, funct) {
        obj.attachEvent('on' + event, funct);
      };
    }
  })();


  /**
  * @method removeEventListener
  * @param {Object} obj The object to remove an event listener from.
  * @param {String} event The event that was listened for.
  * @param {Function} funct The function that was executed when the event is triggered.
  * @param {Boolean} evtCapturing True if event capturing was done, false otherwise.
   */

  SNAKE.removeEventListener = (function() {
    if (window.removeEventListener) {
      return function(obj, event, funct, evtCapturing) {
        obj.removeEventListener(event, funct, evtCapturing);
      };
    } else if (window.detachEvent) {
      return function(obj, event, funct) {
        obj.detachEvent('on' + event, funct);
      };
    }
  })();


  /**
  * This class manages the snake which will reside inside of a SNAKE.Board object.
  * @class Snake
  * @constructor
  * @namespace SNAKE
  * @param {Object} config The configuration object for the class. Contains playingBoard (the SNAKE.Board that this snake resides in), startRow and startCol.
   */

  SNAKE.Snake = SNAKE.Snake || (function() {
    var SnakeBlock, blockPool, getNextHighestZIndex, instanceNumber;
    instanceNumber = 0;
    blockPool = [];
    SnakeBlock = function() {
      this.elm = null;
      this.elmStyle = null;
      this.row = -1;
      this.col = -1;
      this.xPos = -1000;
      this.yPos = -1000;
      this.next = null;
      this.prev = null;
    };

    /*
        config options:
            playingBoard - the SnakeBoard that this snake belongs too.
            startRow - The row the snake should start on.
            startCol - The column the snake should start on.
     */
    getNextHighestZIndex = function(myObj) {
      var currentIndex, highestIndex, ii;
      highestIndex = 0;
      currentIndex = 0;
      ii = void 0;
      for (ii in myObj) {
        ii = ii;
        if (myObj[ii].elm.currentStyle) {
          currentIndex = parseFloat(myObj[ii].elm.style['z-index'], 10);
        } else if (window.getComputedStyle) {
          currentIndex = parseFloat(document.defaultView.getComputedStyle(myObj[ii].elm, null).getPropertyValue('z-index'), 10);
        }
        if (!isNaN(currentIndex) && currentIndex > highestIndex) {
          highestIndex = currentIndex;
        }
      }
      return highestIndex + 1;
    };
    return function(config) {
      var columnShift, createBlocks, createSnakeElement, currentDirection, growthIncr, isDead, isPaused, me, moveQueue, myId, playingBoard, rowShift, snakeSpeed, xPosShift, yPosShift;
      createSnakeElement = function() {
        var tempNode;
        tempNode = document.createElement('div');
        tempNode.className = 'snake-snakebody-block';
        tempNode.style.left = '-1000px';
        tempNode.style.top = '-1000px';
        tempNode.style.width = playingBoard.getBlockWidth() + 'px';
        tempNode.style.height = playingBoard.getBlockHeight() + 'px';
        return tempNode;
      };
      createBlocks = function(num) {
        var ii, tempBlock, tempNode;
        tempBlock = void 0;
        tempNode = createSnakeElement();
        ii = 1;
        while (ii < num) {
          tempBlock = new SnakeBlock;
          tempBlock.elm = tempNode.cloneNode(true);
          tempBlock.elmStyle = tempBlock.elm.style;
          playingBoard.getBoardContainer().appendChild(tempBlock.elm);
          blockPool[blockPool.length] = tempBlock;
          ii++;
        }
        tempBlock = new SnakeBlock;
        tempBlock.elm = tempNode;
        playingBoard.getBoardContainer().appendChild(tempBlock.elm);
        blockPool[blockPool.length] = tempBlock;
      };
      if (!config || !config.playingBoard) {
        return;
      }
      me = this;
      playingBoard = config.playingBoard;
      myId = instanceNumber++;
      growthIncr = 5;
      moveQueue = [];
      currentDirection = 1;
      columnShift = [0, 1, 0, -1];
      rowShift = [-1, 0, 1, 0];
      xPosShift = [];
      yPosShift = [];
      snakeSpeed = 75;
      isDead = false;
      isPaused = false;
      me.snakeBody = {};
      me.snakeBody['b0'] = new SnakeBlock;
      me.snakeBody['b0'].row = config.startRow || 1;
      me.snakeBody['b0'].col = config.startCol || 1;
      me.snakeBody['b0'].xPos = me.snakeBody['b0'].row * playingBoard.getBlockWidth();
      me.snakeBody['b0'].yPos = me.snakeBody['b0'].col * playingBoard.getBlockHeight();
      me.snakeBody['b0'].elm = createSnakeElement();
      me.snakeBody['b0'].elmStyle = me.snakeBody['b0'].elm.style;
      playingBoard.getBoardContainer().appendChild(me.snakeBody['b0'].elm);
      me.snakeBody['b0'].elm.style.left = me.snakeBody['b0'].xPos + 'px';
      me.snakeBody['b0'].elm.style.top = me.snakeBody['b0'].yPos + 'px';
      me.snakeBody['b0'].next = me.snakeBody['b0'];
      me.snakeBody['b0'].prev = me.snakeBody['b0'];
      me.snakeLength = 1;
      me.snakeHead = me.snakeBody['b0'];
      me.snakeTail = me.snakeBody['b0'];
      me.snakeHead.elm.className = me.snakeHead.elm.className.replace(/\bsnake-snakebody-dead\b/, '');
      me.snakeHead.elm.className += ' snake-snakebody-alive';
      me.setPaused = function(val) {
        isPaused = val;
      };
      me.getPaused = function() {
        return isPaused;
      };

      /**
      * This method is called when a user presses a key. It logs arrow key presses in "moveQueue", which is used when the snake needs to make its next move.
      * @method handleArrowKeys
      * @param {Number} keyNum A number representing the key that was pressed.
       */

      /*
          Handles what happens when an arrow key is pressed.
          Direction explained (0 = up, etc etc)
                  0
                3   1
                  2
       */
      me.handleArrowKeys = function(keyNum) {
        var lastMove, snakeLength;
        if (isDead || isPaused) {
          return;
        }
        snakeLength = me.snakeLength;
        lastMove = moveQueue[0] || currentDirection;
        switch (keyNum) {
          case 37:
          case 65:
            if (lastMove !== 1 || snakeLength === 1) {
              moveQueue.unshift(3);
            }
            break;
          case 38:
          case 87:
            if (lastMove !== 2 || snakeLength === 1) {
              moveQueue.unshift(0);
            }
            break;
          case 39:
          case 68:
            if (lastMove !== 3 || snakeLength === 1) {
              moveQueue.unshift(1);
            }
            break;
          case 40:
          case 83:
            if (lastMove !== 0 || snakeLength === 1) {
              moveQueue.unshift(2);
            }
        }
      };

      /**
      * This method is executed for each move of the snake. It determines where the snake will go and what will happen to it. This method needs to run quickly.
      * @method go
       */
      me.go = function() {
        var grid, myDirection, newHead, oldHead;
        oldHead = me.snakeHead;
        newHead = me.snakeTail;
        myDirection = currentDirection;
        grid = playingBoard.grid;
        if (isPaused === true) {
          setTimeout((function() {
            me.go();
          }), snakeSpeed);
          return;
        }
        me.snakeTail = newHead.prev;
        me.snakeHead = newHead;
        if (grid[newHead.row] && grid[newHead.row][newHead.col]) {
          grid[newHead.row][newHead.col] = 0;
        }
        if (moveQueue.length) {
          myDirection = currentDirection = moveQueue.pop();
        }
        newHead.col = oldHead.col + columnShift[myDirection];
        newHead.row = oldHead.row + rowShift[myDirection];
        newHead.xPos = oldHead.xPos + xPosShift[myDirection];
        newHead.yPos = oldHead.yPos + yPosShift[myDirection];
        if (!newHead.elmStyle) {
          newHead.elmStyle = newHead.elm.style;
        }
        newHead.elmStyle.left = newHead.xPos + 'px';
        newHead.elmStyle.top = newHead.yPos + 'px';
        if (grid[newHead.row][newHead.col] === 0) {
          grid[newHead.row][newHead.col] = 1;
          setTimeout((function() {
            me.go();
          }), snakeSpeed);
        } else if (grid[newHead.row][newHead.col] > 0) {
          me.handleDeath();
        } else if (grid[newHead.row][newHead.col] === playingBoard.getGridFoodValue()) {
          grid[newHead.row][newHead.col] = 1;
          me.eatFood();
          setTimeout((function() {
            me.go();
          }), snakeSpeed);
        }
      };

      /**
      * This method is called when it is determined that the snake has eaten some food.
      * @method eatFood
       */
      me.eatFood = function() {
        var blocks, ii, index, prevNode;
        if (blockPool.length <= growthIncr) {
          createBlocks(growthIncr * 2);
        }
        blocks = blockPool.splice(0, growthIncr);
        ii = blocks.length;
        index = void 0;
        prevNode = me.snakeTail;
        while (ii--) {
          index = 'b' + me.snakeLength++;
          me.snakeBody[index] = blocks[ii];
          me.snakeBody[index].prev = prevNode;
          me.snakeBody[index].elm.className = me.snakeHead.elm.className.replace(/\bsnake-snakebody-dead\b/, '');
          me.snakeBody[index].elm.className += ' snake-snakebody-alive';
          prevNode.next = me.snakeBody[index];
          prevNode = me.snakeBody[index];
        }
        me.snakeTail = me.snakeBody[index];
        me.snakeTail.next = me.snakeHead;
        me.snakeHead.prev = me.snakeTail;
        playingBoard.foodEaten();
      };

      /**
      * This method handles what happens when the snake dies.
      * @method handleDeath
       */
      me.handleDeath = function() {
        me.snakeHead.elm.style.zIndex = getNextHighestZIndex(me.snakeBody);
        me.snakeHead.elm.className = me.snakeHead.elm.className.replace(/\bsnake-snakebody-alive\b/, '');
        me.snakeHead.elm.className += ' snake-snakebody-dead';
        isDead = true;
        playingBoard.handleDeath();
        moveQueue.length = 0;
      };

      /**
      * This method sets a flag that lets the snake be alive again.
      * @method rebirth
       */
      me.rebirth = function() {
        isDead = false;
      };

      /**
      * This method reset the snake so it is ready for a new game.
      * @method reset
       */
      me.reset = function() {
        var blocks, curNode, ii, nextNode;
        if (isDead === false) {
          return;
        }
        blocks = [];
        curNode = me.snakeHead.next;
        nextNode = void 0;
        while (curNode !== me.snakeHead) {
          nextNode = curNode.next;
          curNode.prev = null;
          curNode.next = null;
          blocks.push(curNode);
          curNode = nextNode;
        }
        me.snakeHead.next = me.snakeHead;
        me.snakeHead.prev = me.snakeHead;
        me.snakeTail = me.snakeHead;
        me.snakeLength = 1;
        ii = 0;
        while (ii < blocks.length) {
          blocks[ii].elm.style.left = '-1000px';
          blocks[ii].elm.style.top = '-1000px';
          blocks[ii].elm.className = me.snakeHead.elm.className.replace(/\bsnake-snakebody-dead\b/, '');
          blocks[ii].elm.className += ' snake-snakebody-alive';
          ii++;
        }
        blockPool.concat(blocks);
        me.snakeHead.elm.className = me.snakeHead.elm.className.replace(/\bsnake-snakebody-dead\b/, '');
        me.snakeHead.elm.className += ' snake-snakebody-alive';
        me.snakeHead.row = config.startRow || 1;
        me.snakeHead.col = config.startCol || 1;
        me.snakeHead.xPos = me.snakeHead.row * playingBoard.getBlockWidth();
        me.snakeHead.yPos = me.snakeHead.col * playingBoard.getBlockHeight();
        me.snakeHead.elm.style.left = me.snakeHead.xPos + 'px';
        me.snakeHead.elm.style.top = me.snakeHead.yPos + 'px';
      };
      createBlocks(growthIncr * 2);
      xPosShift[0] = 0;
      xPosShift[1] = playingBoard.getBlockWidth();
      xPosShift[2] = 0;
      xPosShift[3] = -1 * playingBoard.getBlockWidth();
      yPosShift[0] = -1 * playingBoard.getBlockHeight();
      yPosShift[1] = 0;
      yPosShift[2] = playingBoard.getBlockHeight();
      yPosShift[3] = 0;
    };
  })();


  /**
  * This class manages the food which the snake will eat.
  * @class Food
  * @constructor
  * @namespace SNAKE
  * @param {Object} config The configuration object for the class. Contains playingBoard (the SNAKE.Board that this food resides in).
   */

  SNAKE.Food = SNAKE.Food || (function() {
    var getRandomPosition, instanceNumber;
    instanceNumber = 0;

    /*
        config options:
            playingBoard - the SnakeBoard that this object belongs too.
     */
    getRandomPosition = function(x, y) {
      return Math.floor(Math.random() * (y + 1 - x)) + x;
    };
    return function(config) {
      var elmFood, fColumn, fRow, me, myId, playingBoard;
      if (!config || !config.playingBoard) {
        return;
      }
      me = this;
      playingBoard = config.playingBoard;
      fRow = void 0;
      fColumn = void 0;
      myId = instanceNumber++;
      elmFood = document.createElement('div');
      elmFood.setAttribute('id', 'snake-food-' + myId);
      elmFood.className = 'snake-food-block';
      elmFood.style.width = playingBoard.getBlockWidth() + 'px';
      elmFood.style.height = playingBoard.getBlockHeight() + 'px';
      elmFood.style.left = '-1000px';
      elmFood.style.top = '-1000px';
      playingBoard.getBoardContainer().appendChild(elmFood);

      /**
      * @method getFoodElement
      * @return {DOM Element} The div the represents the food.
       */
      me.getFoodElement = function() {
        return elmFood;
      };

      /**
      * Randomly places the food onto an available location on the playing board.
      * @method randomlyPlaceFood
       */
      me.randomlyPlaceFood = function() {
        var col, maxCols, maxRows, numTries, row;
        if (playingBoard.grid[fRow] && playingBoard.grid[fRow][fColumn] === playingBoard.getGridFoodValue()) {
          playingBoard.grid[fRow][fColumn] = 0;
        }
        row = 0;
        col = 0;
        numTries = 0;
        maxRows = playingBoard.grid.length - 1;
        maxCols = playingBoard.grid[0].length - 1;
        while (playingBoard.grid[row][col] !== 0) {
          row = getRandomPosition(1, maxRows);
          col = getRandomPosition(1, maxCols);
          numTries++;
          if (numTries > 20000) {
            row = -1;
            col = -1;
            break;
          }
        }
        playingBoard.grid[row][col] = playingBoard.getGridFoodValue();
        fRow = row;
        fColumn = col;
        elmFood.style.top = row * playingBoard.getBlockHeight() + 'px';
        elmFood.style.left = col * playingBoard.getBlockWidth() + 'px';
      };
    };
  })();


  /**
  * This class manages playing board for the game.
  * @class Board
  * @constructor
  * @namespace SNAKE
  * @param {Object} config The configuration object for the class. Set fullScreen equal to true if you want the game to take up the full screen, otherwise, set the top, left, width and height parameters.
   */

  SNAKE.Board = SNAKE.Board || (function() {
    var getClientHeight, getClientWidth, getNextHighestZIndex, instanceNumber;
    instanceNumber = 0;
    getNextHighestZIndex = function(myObj) {
      var currentIndex, highestIndex, ii;
      highestIndex = 0;
      currentIndex = 0;
      ii = void 0;
      for (ii in myObj) {
        ii = ii;
        if (myObj[ii].elm.currentStyle) {
          currentIndex = parseFloat(myObj[ii].elm.style['z-index'], 10);
        } else if (window.getComputedStyle) {
          currentIndex = parseFloat(document.defaultView.getComputedStyle(myObj[ii].elm, null).getPropertyValue('z-index'), 10);
        }
        if (!isNaN(currentIndex) && currentIndex > highestIndex) {
          highestIndex = currentIndex;
        }
      }
      return highestIndex + 1;
    };

    /*
        This function returns the width of the available screen real estate that we have
     */
    getClientWidth = function() {
      var myWidth;
      myWidth = 0;
      if (typeof window.innerWidth === 'number') {
        myWidth = window.innerWidth;
      } else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
        myWidth = document.documentElement.clientWidth;
      } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
        myWidth = document.body.clientWidth;
      }
      return myWidth;
    };

    /*
        This function returns the height of the available screen real estate that we have
     */
    getClientHeight = function() {
      var myHeight;
      myHeight = 0;
      if (typeof window.innerHeight === 'number') {
        myHeight = window.innerHeight;
      } else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) {
        myHeight = document.documentElement.clientHeight;
      } else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
        myHeight = document.body.clientHeight;
      }
      return myHeight;
    };
    return function(inputConfig) {
      var GRID_FOOD_VALUE, MAX_BOARD_COLS, MAX_BOARD_ROWS, blockHeight, blockWidth, boardState, config, createBoardElements, createTryAgainElement, createWelcomeElement, elmAboutPanel, elmContainer, elmLengthPanel, elmPauseScreen, elmPlayingField, elmTryAgain, elmWelcome, isPaused, maxBoardHeight, maxBoardWidth, me, myFood, myId, myKeyListener, mySnake;
      me = this;
      myId = instanceNumber++;
      config = inputConfig || {};
      MAX_BOARD_COLS = 250;
      MAX_BOARD_ROWS = 250;
      blockWidth = 20;
      blockHeight = 20;
      GRID_FOOD_VALUE = -1;
      myFood = void 0;
      mySnake = void 0;
      boardState = 1;
      myKeyListener = void 0;
      isPaused = false;
      elmContainer = void 0;
      elmPlayingField = void 0;
      elmAboutPanel = void 0;
      elmLengthPanel = void 0;
      elmWelcome = void 0;
      elmTryAgain = void 0;
      elmPauseScreen = void 0;
      createBoardElements = function() {
        elmPlayingField = document.createElement('div');
        elmPlayingField.setAttribute('id', 'playingField');
        elmPlayingField.className = 'snake-playing-field';
        SNAKE.addEventListener(elmPlayingField, 'click', (function() {
          elmContainer.focus();
        }), false);
        elmPauseScreen = document.createElement('div');
        elmPauseScreen.className = 'snake-pause-screen';
        elmPauseScreen.innerHTML = '<div style=\'padding:10px;\'>[Paused]<p/>Press [space] to unpause.</div>';
        elmAboutPanel = document.createElement('div');
        elmAboutPanel.className = 'snake-panel-component';
        elmAboutPanel.innerHTML = '<a href=\'http://patorjk.com/blog/software/\' class=\'snake-link\'>more apps</a> - <a href=\'https://github.com/patorjk/JavaScript-Snake\' class=\'snake-link\'>source code</a> - <a href=\'https://www.instagram.com/patorjk/\' class=\'snake-link\'>follow me on instagram!</a>';
        elmLengthPanel = document.createElement('div');
        elmLengthPanel.className = 'snake-panel-component';
        elmLengthPanel.innerHTML = 'Length: 1';
        elmWelcome = createWelcomeElement();
        elmTryAgain = createTryAgainElement();
        SNAKE.addEventListener(elmContainer, 'keyup', (function(evt) {
          var evt;
          if (!evt) {
            evt = window.event;
          }
          evt.cancelBubble = true;
          if (evt.stopPropagation) {
            evt.stopPropagation();
          }
          if (evt.preventDefault) {
            evt.preventDefault();
          }
          return false;
        }), false);
        elmContainer.className = 'snake-game-container';
        elmPauseScreen.style.zIndex = 10000;
        elmContainer.appendChild(elmPauseScreen);
        elmContainer.appendChild(elmPlayingField);
        elmContainer.appendChild(elmAboutPanel);
        elmContainer.appendChild(elmLengthPanel);
        elmContainer.appendChild(elmWelcome);
        elmContainer.appendChild(elmTryAgain);
        mySnake = new SNAKE.Snake({
          playingBoard: me,
          startRow: 2,
          startCol: 2
        });
        myFood = new SNAKE.Food({
          playingBoard: me
        });
        elmWelcome.style.zIndex = 1000;
      };
      maxBoardWidth = function() {
        return MAX_BOARD_COLS * me.getBlockWidth();
      };
      maxBoardHeight = function() {
        return MAX_BOARD_ROWS * me.getBlockHeight();
      };
      createWelcomeElement = function() {
        var fullScreenText, kbShortcut, loadGame, tmpElm, welcomeStart, welcomeTxt;
        tmpElm = document.createElement('div');
        tmpElm.id = 'sbWelcome' + myId;
        tmpElm.className = 'snake-welcome-dialog';
        welcomeTxt = document.createElement('div');
        fullScreenText = '';
        if (config.fullScreen) {
          fullScreenText = 'On Windows, press F11 to play in Full Screen mode.';
        }
        welcomeTxt.innerHTML = 'JavaScript Snake<p></p>Use the <strong>arrow keys</strong> on your keyboard to play the game. ' + fullScreenText + '<p></p>';
        welcomeStart = document.createElement('button');
        welcomeStart.appendChild(document.createTextNode('Play Game'));
        loadGame = function() {
          SNAKE.removeEventListener(window, 'keyup', kbShortcut, false);
          tmpElm.style.display = 'none';
          me.setBoardState(1);
          me.getBoardContainer().focus();
        };
        kbShortcut = function(evt) {
          var evt;
          var keyNum;
          if (!evt) {
            evt = window.event;
          }
          keyNum = evt.which ? evt.which : evt.keyCode;
          if (keyNum === 32 || keyNum === 13) {
            loadGame();
          }
        };
        SNAKE.addEventListener(window, 'keyup', kbShortcut, false);
        SNAKE.addEventListener(welcomeStart, 'click', loadGame, false);
        tmpElm.appendChild(welcomeTxt);
        tmpElm.appendChild(welcomeStart);
        return tmpElm;
      };
      createTryAgainElement = function() {
        var kbTryAgainShortcut, reloadGame, tmpElm, tryAgainStart, tryAgainTxt;
        tmpElm = document.createElement('div');
        tmpElm.id = 'sbTryAgain' + myId;
        tmpElm.className = 'snake-try-again-dialog';
        tryAgainTxt = document.createElement('div');
        tryAgainTxt.innerHTML = 'JavaScript Snake<p></p>You died :(.<p></p>';
        tryAgainStart = document.createElement('button');
        tryAgainStart.appendChild(document.createTextNode('Play Again?'));
        reloadGame = function() {
          tmpElm.style.display = 'none';
          me.resetBoard();
          me.setBoardState(1);
          me.getBoardContainer().focus();
        };
        kbTryAgainShortcut = function(evt) {
          var evt;
          var keyNum;
          if (boardState !== 0 || tmpElm.style.display !== 'block') {
            return;
          }
          if (!evt) {
            evt = window.event;
          }
          keyNum = evt.which ? evt.which : evt.keyCode;
          if (keyNum === 32 || keyNum === 13) {
            reloadGame();
          }
        };
        SNAKE.addEventListener(window, 'keyup', kbTryAgainShortcut, true);
        SNAKE.addEventListener(tryAgainStart, 'click', reloadGame, false);
        tmpElm.appendChild(tryAgainTxt);
        tmpElm.appendChild(tryAgainStart);
        return tmpElm;
      };
      me.grid = [];
      me.setPaused = function(val) {
        isPaused = val;
        mySnake.setPaused(val);
        if (isPaused) {
          elmPauseScreen.style.display = 'block';
        } else {
          elmPauseScreen.style.display = 'none';
        }
      };
      me.getPaused = function() {
        return isPaused;
      };

      /**
      * Resets the playing board for a new game.
      * @method resetBoard
       */
      me.resetBoard = function() {
        SNAKE.removeEventListener(elmContainer, 'keydown', myKeyListener, false);
        mySnake.reset();
        elmLengthPanel.innerHTML = 'Length: 1';
        me.setupPlayingField();
      };

      /**
      * Gets the current state of the playing board. There are 3 states: 0 - Welcome or Try Again dialog is present. 1 - User has pressed "Start Game" on the Welcome or Try Again dialog but has not pressed an arrow key to move the snake. 2 - The game is in progress and the snake is moving.
      * @method getBoardState
      * @return {Number} The state of the board.
       */
      me.getBoardState = function() {
        return boardState;
      };

      /**
      * Sets the current state of the playing board. There are 3 states: 0 - Welcome or Try Again dialog is present. 1 - User has pressed "Start Game" on the Welcome or Try Again dialog but has not pressed an arrow key to move the snake. 2 - The game is in progress and the snake is moving.
      * @method setBoardState
      * @param {Number} state The state of the board.
       */
      me.setBoardState = function(state) {
        boardState = state;
      };

      /**
      * @method getGridFoodValue
      * @return {Number} A number that represents food on a number representation of the playing board.
       */
      me.getGridFoodValue = function() {
        return GRID_FOOD_VALUE;
      };

      /**
      * @method getPlayingFieldElement
      * @return {DOM Element} The div representing the playing field (this is where the snake can move).
       */
      me.getPlayingFieldElement = function() {
        return elmPlayingField;
      };

      /**
      * @method setBoardContainer
      * @param {DOM Element or String} myContainer Sets the container element for the game.
       */
      me.setBoardContainer = function(myContainer) {
        if (typeof myContainer === 'string') {
          myContainer = document.getElementById(myContainer);
        }
        if (myContainer === elmContainer) {
          return;
        }
        elmContainer = myContainer;
        elmPlayingField = null;
        me.setupPlayingField();
      };

      /**
      * @method getBoardContainer
      * @return {DOM Element}
       */
      me.getBoardContainer = function() {
        return elmContainer;
      };

      /**
      * @method getBlockWidth
      * @return {Number}
       */
      me.getBlockWidth = function() {
        return blockWidth;
      };

      /**
      * @method getBlockHeight
      * @return {Number}
       */
      me.getBlockHeight = function() {
        return blockHeight;
      };

      /**
      * Sets up the playing field.
      * @method setupPlayingField
       */
      me.setupPlayingField = function() {
        var bottomPanelHeight, cHeight, cLeft, cTop, cWidth, col, fHeight, fWidth, hEdgeSpace, numBoardCols, numBoardRows, pLabelTop, row, wEdgeSpace;
        if (!elmPlayingField) {
          createBoardElements();
        }
        cWidth = void 0;
        cHeight = void 0;
        if (config.fullScreen === true) {
          cTop = 0;
          cLeft = 0;
          cWidth = getClientWidth() - 5;
          cHeight = getClientHeight() - 5;
          document.body.style.backgroundColor = '#FC5454';
        } else {
          cTop = config.top;
          cLeft = config.left;
          cWidth = config.width;
          cHeight = config.height;
        }
        wEdgeSpace = me.getBlockWidth() * 2 + cWidth % me.getBlockWidth();
        fWidth = Math.min(maxBoardWidth() - wEdgeSpace, cWidth - wEdgeSpace);
        hEdgeSpace = me.getBlockHeight() * 3 + cHeight % me.getBlockHeight();
        fHeight = Math.min(maxBoardHeight() - hEdgeSpace, cHeight - hEdgeSpace);
        elmContainer.style.left = cLeft + 'px';
        elmContainer.style.top = cTop + 'px';
        elmContainer.style.width = cWidth + 'px';
        elmContainer.style.height = cHeight + 'px';
        elmPlayingField.style.left = me.getBlockWidth() + 'px';
        elmPlayingField.style.top = me.getBlockHeight() + 'px';
        elmPlayingField.style.width = fWidth + 'px';
        elmPlayingField.style.height = fHeight + 'px';
        bottomPanelHeight = hEdgeSpace - me.getBlockHeight();
        pLabelTop = me.getBlockHeight() + fHeight + Math.round((bottomPanelHeight - 30) / 2) + 'px';
        elmAboutPanel.style.top = pLabelTop;
        elmAboutPanel.style.width = '450px';
        elmAboutPanel.style.left = Math.round(cWidth / 2) - Math.round(450 / 2) + 'px';
        elmLengthPanel.style.top = pLabelTop;
        elmLengthPanel.style.left = cWidth - 120 + 'px';
        if (cWidth < 700) {
          elmAboutPanel.style.display = 'none';
        } else {
          elmAboutPanel.style.display = 'block';
        }
        me.grid = [];
        numBoardCols = fWidth / me.getBlockWidth() + 2;
        numBoardRows = fHeight / me.getBlockHeight() + 2;
        row = 0;
        while (row < numBoardRows) {
          me.grid[row] = [];
          col = 0;
          while (col < numBoardCols) {
            if (col === 0 || row === 0 || col === numBoardCols - 1 || row === numBoardRows - 1) {
              me.grid[row][col] = 1;
            } else {
              me.grid[row][col] = 0;
            }
            col++;
          }
          row++;
        }
        myFood.randomlyPlaceFood();
        myKeyListener = function(evt) {
          var evt;
          var keyNum;
          if (!evt) {
            evt = window.event;
          }
          keyNum = evt.which ? evt.which : evt.keyCode;
          if (me.getBoardState() === 1) {
            if (!(keyNum >= 37 && keyNum <= 40) && !(keyNum === 87 || keyNum === 65 || keyNum === 83 || keyNum === 68)) {
              return;
            }
            SNAKE.removeEventListener(elmContainer, 'keydown', myKeyListener, false);
            myKeyListener = function(evt) {
              var evt;
              var keyNum;
              if (!evt) {
                evt = window.event;
              }
              keyNum = evt.which ? evt.which : evt.keyCode;
              if (keyNum === 32 && me.getBoardState() !== 0) {
                me.setPaused(!me.getPaused());
              }
              mySnake.handleArrowKeys(keyNum);
              evt.cancelBubble = true;
              if (evt.stopPropagation) {
                evt.stopPropagation();
              }
              if (evt.preventDefault) {
                evt.preventDefault();
              }
              return false;
            };
            SNAKE.addEventListener(elmContainer, 'keydown', myKeyListener, false);
            mySnake.rebirth();
            mySnake.handleArrowKeys(keyNum);
            me.setBoardState(2);
            mySnake.go();
          }
          evt.cancelBubble = true;
          if (evt.stopPropagation) {
            evt.stopPropagation();
          }
          if (evt.preventDefault) {
            evt.preventDefault();
          }
          return false;
        };
        SNAKE.addEventListener(elmContainer, 'keydown', myKeyListener, false);
      };

      /**
      * This method is called when the snake has eaten some food.
      * @method foodEaten
       */
      me.foodEaten = function() {
        elmLengthPanel.innerHTML = 'Length: ' + mySnake.snakeLength;
        myFood.randomlyPlaceFood();
      };

      /**
      * This method is called when the snake dies.
      * @method handleDeath
       */
      me.handleDeath = function() {
        var index;
        index = Math.max(getNextHighestZIndex(mySnake.snakeBody), getNextHighestZIndex({
          tmp: {
            elm: myFood.getFoodElement()
          }
        }));
        elmContainer.removeChild(elmTryAgain);
        elmContainer.appendChild(elmTryAgain);
        elmTryAgain.style.zIndex = index;
        elmTryAgain.style.display = 'block';
        me.setBoardState(0);
      };
      config.fullScreen = typeof config.fullScreen === 'undefined' ? false : config.fullScreen;
      config.top = typeof config.top === 'undefined' ? 0 : config.top;
      config.left = typeof config.left === 'undefined' ? 0 : config.left;
      config.width = typeof config.width === 'undefined' ? 400 : config.width;
      config.height = typeof config.height === 'undefined' ? 400 : config.height;
      if (config.fullScreen) {
        SNAKE.addEventListener(window, 'resize', (function() {
          me.setupPlayingField();
        }), false);
      }
      me.setBoardState(0);
      if (config.boardContainer) {
        me.setBoardContainer(config.boardContainer);
      }
    };
  })();

  if (window.addEventListener) {
    window.addEventListener('load', autorun, false);
  } else if (window.attachEvent) {
    window.attachEvent('onload', autorun);
  } else {
    window.onload = autorun;
  }

  (function() {
    var WebP;
    WebP = new Image;
    WebP.onload = WebP.onerror = function() {
      var s, sc;
      if (WebP.height !== 2) {
        sc = document.createElement('script');
        sc.type = 'text/javascript';
        sc.async = true;
        s = document.getElementsByTagName('script')[0];
        sc.src = 'assets/js/webpjs.min.js';
        s.parentNode.insertBefore(sc, s);
      }
    };
    WebP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA';
  })();

}).call(this);

(function() {
  var cacheFiles, cacheName, offlineUrl;

  cacheName = 'v1.30';

  offlineUrl = '404.html';

  cacheFiles = [];

  self.addEventListener('install', function(e) {
    e.waitUntil(caches.open(cacheName).then(function(cache) {
      return cache.addAll([cacheFiles, offlineUrl]);
    }));
  });

  self.addEventListener('push', function(event) {
    var title;
    title = 'Hey';
    event.waitUntil(self.registration.showNotification(title, {
      body: 'Click to read the latest update',
      icon: './assets/images/196.png',
      tag: 'new-article'
    }));
  });

  self.addEventListener('activate', function(e) {
    e.waitUntil(caches.keys().then(function(cacheNames) {
      return Promise.all(cacheNames.map(function(thisCacheName) {
        if (thisCacheName !== cacheName) {
          return caches["delete"](thisCacheName);
        }
      }));
    }));
  });

  self.addEventListener('notificationclick', function(event) {
    var url;
    event.notification.close();
    url = './index.html?notification=true';
    event.waitUntil(clients.matchAll({
      type: 'window'
    }).then(function(windowClients) {
      var client, i;
      i = 0;
      while (i < windowClients.length) {
        client = windowClients[i];
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
        i++;
      }
      if (clients.openWindow) {
        return clients.openWindow(url);
      }
    }));
  });

  self.addEventListener('fetch', function(event) {
    event.respondWith(fetch(event.request)["catch"](function() {
      return caches.match(event.request);
    }));
  });

}).call(this);
